# 연산자

### 연산의 사전적 의미
- 규칙에 따라 계산하여 값을 구함

### 연산자(Operator) 형태
- +, -, *, /, %
- >, >=, <, <=
- ==, !=, ===, !==
- 콤마(,), typeof, delete, void
- instanceof, in, new 등

<br>

# 표현식

### 표현식(Expression) 형태
- 1 + 2
- var total = 1 + 2;
- var value = total / (2 + 3);

### "표현식을 평가" 한다고 함

### 표현식을 평가하면 결과가 반환되며
- 이를 평가 결과라고 함
- JS는 표현식의 연결

<br>

# 할당 연산자

### 단일 할다아 연산자
- = 하나만 사용
- var result = 1 + 2;

### 복합 할당 연산자
- = 앞에 연산자 작성
- +=, -=, *=, /=, %=
- <<=, >>=
- >>>=, &=, ^=,|=

### 먼저 = 앞을 연산한 후, 할당
- var point = 7;
- point += 3;

<br>

# 해석, 실행 순서

### 해석이란?
- JS 코드를 기계어로 바꾸는 것
- 엔진이 해석하고 실행한다

### 실행 순서
- var result = 1 + 2 + 6;
- = 왼쪽의 표현식 평가
- = 오른쪽의 표현식 평가
    왼쪽에서 오른쪽으로 평가 (1 + 2, 3 + 6)
- = 오른쪽 표현식의 평과 결과를 왼쪽 표현식 평가 결과에 할당

<br>

# 산술 연산자 (+)

### + 양쪽의 표현식을 평가
- 평가 결과를 더함
```
var value = 1 + 2 + 4;
log(value);
```
1. 우선 2과 2를 더하고
2. 이어서 더한 값(3)에 4를 더함
3. 그리고 더한 값(7)을 value 변수에 할당
[실행 결과]
7

### 평가 결과 연결
- 한 쪽이라도 숫자가 아니면 연결
```
var two = '2';
var value = 1 + two;
log(value);
log(typeof value);
```
1. 한 쪽이라도 평가 결과가 Number 타입이 아니면 평가 결과를 더하지 않고 연결함
[실행 결과]
12
string

### 왼쪽에서 오른쪽으로 연산
- 1 + 5 + "ABC"의 결과는?
```
var value = 1 + 5 + 'ABC';
log(value);
```
1. 우선 1과 5를 더하면 6이 됨
2. 이어서 6과 'ABC'를 연결
[실행 결과]
6ABC

<br>

# 숫자로 변환

### 연산하기 전에 우선 숫자로 변환

### 변환된 값으로 연산
|값 타입|변환 값|
|------|---|
|Undefined|NaN|
|Null|+0|
|Boolean|true : 1, false : 0|
|Number|변환 전/후 같음|
|String|값이 숫자면 숫자로 연산 단, 더하기는(+)는 연결|
```
var value;
log(10 + value);
```
1. value 값은 undefined
2. 10과 undefined를 더하면 NaN
[실행 결과]
NaN

```
log(10 + null);
log(10 + true);
log(10 + false);
```
1. null은 0으로 변환
2. true는 1, false는 0으로 변환
[실행 결과]
10
11
10

```
log(10 + '123');
log(123 = '23');
```
1. 더하기는 값이 숫자라도 타입이 String이면 문자열로 연결
2. -, *, /는 숫자로 변환하여 연산
3. typeof 연산자로 Number 타입 여부 체크
[실행 결과]
10123
100

<br>

# - 연산자

### 왼쪽 표현식 평가 결과에서 오른쪽 표현식 평가 결과를 뺌

### String 타입이지만, 값이 숫자이면 Number 타입으로 변환하여 계산
```
log('135' - 2);
```
1. '135'가 String 타입이지만 값이 숫자이므로
값을 Number타입으로 변환하여 계산
[실행 결과]
133

<br>

# * 연산자

### 왼쪽 표현식 평가 결과와 오른쪽 표현식 평가 결과를 곱함

### 숫자 값으로 변환할 수 있으면 변환하여 곱함

### NaN 반환
- 양쪽의 평가 결과가 하나라도 숫자가 아닐 때
```
log(10 * '20');
log(10 * true);
log(10 * false);
log(10 * null);
log(10 * 'A');
```
1. 문자 타입이라도 값이 숫자면 숫자 타입으로 변환
2. true를 1로 변환
3. false, null을 0으로 변환
[실행 결과]
200
10
0
0
NaN
- 소수 값이 생기는 경우 처리
```
log(2.3 * 3);
log(2.3 * 10 * 3 / 10);
```
1. 6.9로 출력되지 않음
2. 정상이며, IEEE 754 유동 소수점 처리 때문
3. 대응방법
    - 실수를 정수로 변환하여 값을 구하고
    - 다시 정수를 실수를 변환
[실행 결과]
6.899999999999995
6.9

<br>

# / 연산자

### 왼쪽 표현식 평가 결과를 오른쪽 표현식 평가 결과로 나눔

### NaN 반환
- 양쪽의 평가 결과가 하나라도 숫자가 아닐 때
- 분모, 분자 모두 0일 때

### 분모, 분자가 0일 때
- 분모가 0이면 Infinity 반환
- 분자가 0이면 0 반환

<br>

# % 연산자

### 왼쪽 표현식 평가 결과를 오른쪽 표현식 평가 결과로 나누어 나머지를 구함

### 3 % 2의 나머지는 1
```
log(5 % 2.5);
log(5 % 2.3);
log((5 * 10 - (2 * 2.3 * 10)) / 10);
```
1. 5를 2.5로 나누면 나머지가 0
2. 소수 끝에 36이 있는 것은 IEEE 754의 유동 소수점 처리 때문
3. 실수를 정수로 변환하여 연산하고 다시 정수를 실수로 변환
[실행 결과]
0
0.40000000000000036
0.4

<br>

# 단항 + 연산자

### 형태 : +value

### 값을 Number 타입으로 변환
```
var value = '7';
log(typeof value);
log(typeof +value);
log(tyupeof Number(value));
```
1. String 타입을 Number 타입으로 변환
2. Number() 함수가 가독성이 더 좋음
[실행 결과]
string
number
number

### 코드 가독성
- +를 더하기로 착각할 수도 있음
- Number()도 같은 기능

<br>

# 단항 - 연산자

### 형태 : -value

### 값의 부호를 바꿈
- +는 -로, -는 +로 바꿈

### 연산할 때만 바꿈
- 원래 값은 바뀌지 않음
```
var value = 7;
log(-value);
log(8 + -value);
log(value * (-1));
log(value);
```
1. 7을 -7로 바꿈
2. 8 + (-7)은 1
3. value 변수값의 부호는 바뀌지 않음
[실행 결과]
-7
1
7

<br>

# 후치 ++ 연산자

### 형태 : value++

### 값을 자동으로 1 증가시킴
- 문장을 수항한 후에 1 증가
- 즉, 세미콜론(;) 다음에서 증가
```
var one = 1;
var value = one++ + 3;
log(value);
log(one);
```
1. one++를 하면 1이 2가 되지만 문장 안이므로 1이 증가하지 않음
2. 1 + 3을 하게 되어 4가 됨
[실행 결과]
4
2

<br>

# 전치 ++ 연산자

### 형태 : ++value

### 값을 자동으로 1 증가시킴
- 문장 안에서 1 증가
- 표현식을 평가하지 전에 1 증가, 표현식에서 증가된 값을 사용
```
var one = 1;
var value = ++one + 3;
log(value);
log(one);
```
1. 문장이 끝나기 전이지만 먼저 1을 증가시키고 3을 더함
2. 2 + 3을 하게 되므로 5가 출력
[실행 결과]
5
2

<br>

# ! 연산자

### 논리 NOT 연산자
- 형태 : !value

### 표현식, 평가 결과를 true, false로 변환한 후 true이면 false를, false면 true를 반환

### 원래 값은 바귀지 안으며 사용할 때만 변환
```
var value = true;
log(!value);
log(!!'A');
```
1. true를 바꾸어 false로 출력
2. A는 true, !A는 false, !!A는 true
[실행 결과]
false
true

<br>

# 유니코드

### Unicode
- 세계의 모든 문자를 통합하여 코드화
- 언어, 이모지 등
- 코드 값을 코드 포인트라고 부름
- 0000~FFFF, 10000~2=1FFFF 값에 문자 매핑
- 유니코드 컨소시엄 http://www.unicode.org/

### 표기 방법
- u와 숫자 형태 : u0031은 숫자 1
- JS는 u 앞에 역슬래시(\) 작성
```
log('\u0031');
log('\u0041');
log('\u1100');
log('\uac01');
```
[실행 결과]
1
A
ㄱ
각
- 역슬래시(//) 2개 작성
```
log('\\u0031');
log('\\u0041');
```
- ES에서 표기 방법 추가됨

<br>

# UTF

### Unicode Transformation Format
- 유니코드의 코드 포인트를 매핑하는 방법
- UTF-8, UTF-16, UTF-32로 표기
- <meta charset = 'utf-8'>
- UTF-8은 8비트로 코드 포인트 매핑
- 8비트 인코딩(Encoding)이라고 부름

<br>

# 관계 연산자

### 관계(Relational) 연산자
- <, >, <=, >= 연산자
- instanceof 연산자
- in 연산자

### instanceof, if 연산자
- 사전 설명이 필요하므로 관련된 곳에서 다룰 예정

<br>

# > 연산자

### 부등호 : Greater-than

### 양쪽이 Number 타입일 때
- 왼쪽이 오른쪽보다 크면 true 반환, 아니면 false 반환
```
log(1 + 2) > 1);
```
1. 먼저 표현식을 평가하여 값을 구함
2. 3이 1보다 크므로 true 반환
[실행 결과]
true

### String 타입 비교
- 한 쪽이 String 타입이면 false
```
log(1 > 'A');
```
1. 숫자와 문자열을 비교하면 false
[실행 결과]
false
- 양쪽이 모두 String 타입이면 유니코드 사전 순서로 비교
```
log(('\u0033' > '\u0032'));
log('A' > '1');
log('가' > '다');
```
1. 코드 포인트 \u0033 : 3, \0032 : 2
2. \u0041 : A, \u0031 : 1
3. '가'와 '다'도 유니코드 사전 순서로 비교
[실행 결과]
true
true
false
- 문자 하나씩 비교
```
log('A07' > 'A21');
```
1. 왼쪽에서 오른쪽으로 문자 하나씩 비교
2. A와 A가 같으므로 다음을 비교
3. 0과 2를 비교하게 되며 false 반환
4. 결정이 되면 다음 것은 비교하지 않음
[실행 결과]
false

### <, <=, >=는 비교 기준만 다름

<br>

# == 연산자

### 동등 연산자
- 왼쪽과 오른쪽 값이 같으면 true, 다르면 false
- 값 타입은 비교하지 않음
- 1과 '1'이 같음
```
log(1 == '1');
```
1. 값 타입이 다르면 즉, '문자:숫자', '숫자:문자'일 때 문자 타입을 숫자 타입으로 변환하여 비교
2. 따라서 모두 1이므로 true 변환
[실행 결과]
true

```
var value;
log(value == undefined);
```
1. 양쪽이 모두 undefined이므로 true
[실행 결과]
true

```
var value;
log(value == null);
```
1. undefined와 null을 비교하면 true
2. undefined와 null은 값임
3. 값이 다른데도 true가 되므로 주의!
[실행 결과]
true

<br>

# != 연산자

### 부등 연산자
- 왼쪽과 오른쪽 값이 다르면 true, 같으면 false
- a != b와 !(a == b)가 같음

<br>

# === 연산자

### 일치 연산자
- 왼쪽과 오른쪽의 값과 타입이 모두 같으면 true
- 값 또는 타입이 다르면 false
```
log(1 === '1');
```
1. 값은 같지만 타입이 다르므로 false
[실행 결과]
false

```
var value;
log(value == null);
log(value === null);
```
1. var로 변수를 선언만 하면 변수값은 undefined
2. undefined와 null은 값임
3. ==(동등 연산자)로 비교하면 true, ===(일치 연산자)로 비교하면 타입이 다르므로 false
[실행 결과]
true
false

<br>

# !== 연산자

### 불일치 연산자
- 값 또는 타입이 다르면 true, true가 아니면 false

<br>

# 콤마 연산자

### 기호 : ,(Comma)
- 콤마로 표현식을 분리
- var a = 1, b= 2;
- var 한 번만 작성

<br>

# () 연산자

### 그룹핑 연산자
- 소괄호() 안의 표현식을 먼저 평가
- 평가한 값을 반환
- ex) 5 / (2 + 3)

<br>

# || 연산자

### 논리 OR 연산자
- 표현식의 평가 결과가 하나라도 true이면 true, 아니면 false
```
var value, zero = 0, two = 2;
log(value || zero || two);
```
1. value 변수값이 undefined이므로 false
2. zero 변수값이 0이므로 false
3. two 변수값이 2이므로 true가 되며 two 변수값을 반환
4. true가 아니라 true가 되는 변수값 반환, 2가 true이므로 전체 비교는 true
[실행 결과]
2

```
var value, zero = 0;
log(zero || value);
```
1. 마지막까지 비교하였는데 모두가 false이면 false가 아니라 마지막 변수값 반환
[실행 결과]
undefined
- 왼쪽 결과가 true이면 오른쪽은 비교하지 않음
```
var one = 1;
log(one === 1 || two === 2);
```
1. 왼쪽의 (one === 1) 결과가 true이므로 true 반환
2. 왼쪽 비교 결과가 true이면 오른쪽은 비교하지 않음
3. 오른쪽을 비교하면 two 변수가 없으므로 에러 발생
[실행 결과]
true

<br>

# && 연산자

### 논리 AND 연산자
- 표현식의 평가 결과가 모두 true면 true, 아니면 false
```
var one = 1, two = 2;
log(one && two);
```
1. one 변수값이 1이므로 true, true이므로 오른쪽을 비교
2. two 변수값이 2이므로 true, 모두가 true이며 마지막의 2를 반환
[실행 결과]
2
- 왼쪽 결과가 false이면 오른쪽은 비교하지 않음
```
var one = 1, zero = 0;
log(one && zero && nine);
```
1. one 변수값이 1이므로 true, true이므로 오른쪽 비교
2. zero 변수값이 0이므로 false, 오른쪽 비교하지 않고 zero 변수값인 0 반환
3. nine을 비교하면 nine 변수가 없으므로 에러 발생
[실행 결과]
0

<br>

# 조건 연산자

### 기호 : exp ? exp-1 : exp-2
- 3항 연산자라고도 함

### exp 위치의 표현식을 먼저 평가
- true면 exp-1의 결과 반환
- false면 exp-2의 결과 반환
```
log(1 === 1 ? '같음' : '다름');
log(1 === '1' ? '같음' : '다름');
```
1. 1과 1은 값과 타입이 같으므로 true ? 다음의 표현식을 실행
2. 1과 "1"은 값은 같지만 타입이 다르므로 false : 다음의 표현식을 실행
[실행 결과]
같음
다름

<br>

# 연산자 우선순위

### 연산자의 실행 우선순위
- ECMA-262 스펙에 없음

### MDN Operator precedence

